---
title: "Historical precipitation patterns and seasonal forecasts"
author: "Linda Petutschnig"
date: "31 5 2023"
output: html_document
---

This script performs the following tasks:

 - Loads pre-precessed CHIRPS precipitation data and manipultaes in several ways for data analysis
 - Calculates averages
 - Makes plots to explore the data
 - Clusters the AOI into different rainfall regimes
 - Plots the clusters
 - Calcualtes averages per cluster

To do:
  - Load seasonal precipitation forecast data
  - Decide on and calculate the final indicator
  - Write into hexagons


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load libraries

```{r load libraryies}

library(httr)
library(utils)
library(raster)
library(terra)
library(sf)
library(R.utils)
library(tidyr)
library(dplyr)
library(stringr)
library(lubridate)
library(tsibble)
library(ggplot2)
library(here)
library(purrr)
library(timetk)

source(here("hexagonify.R"))

```


## Preparing the data for time series analysis

```{r prepare data}

# Loads the previously prepared brick
prec_aoi_brick <- terra::rast(here::here("data/rasters", "perc_aoi_brick_90_19.tif"))

# Convert raster cells to points
prec_90_19_points <- rasterToPoints(raster::brick(prec_aoi_brick), spatial = TRUE) %>% 
  st_as_sf() %>% 
  mutate(id = row_number())

# Convert to long
# Transforming the data into long format
# We want one Year column and a value column for our analysis.
# The pivot_long function from the tidyr package is used to transform the data from wide to long format.
prec_long <- prec_90_19_points %>% 
  pivot_longer(
    cols = starts_with("chirps.v2.0"),
    names_to = "Month",
    values_to = "Precipitation"
  )

# Cleans up the Year column
# The Year column names are currently long strings like "Plasmodium..falciparum..Incidence..2000".
# Only need the last four characters indicating the year are needed. 
prec_long$Month <- str_sub(prec_long$Month,-7,-1)      
prec_long$Month <- gsub("\\.(?=\\d{2}$)", "-", prec_long$Month, perl=TRUE)

# Converts the Year column into date format and adds 1st 
prec_long$Month <- as_date(paste0(prec_long$Month, "-01"))

# Converting the long format data table to a time series tibble by id
# Every geographical point is now represented as 360 individual rows (1990 to 2019, monthly) that share the same id.
prec_tsbl <- as_tsibble(prec_long, key = id, index = Month)

# Calculates the monthly precipitation averaging over all locations 
avg <- prec_long %>%
  group_by(Month) %>% 
  summarise(avg_value = mean(Precipitation, na.rm = TRUE))

# Creates a time series plot with each location represented by one line. 
ggplot() + 
  geom_line(data =  prec_long, aes(x = Month, y = Precipitation, group =id), color = "darkseagreen", alpha = 0.1) +
  geom_line(data = avg, aes(x = Month, y = avg_value), color = "salmon", linewidth = 2) +
  labs(x = "Month", y = "Precipitation", title = "Precipitation monthly 1990-2019") +
  theme_minimal(base_size = 14) 

```

## Average monthly rainfall per year  
The next chunk prepares and plots a graph showing the average yearly rainfall pattern of the years 1990-2019 for all locations combined.
```{r average rainfall throughout the year}

# We want one column that contains only the month 
# Extracts from the current column "Month" (that actually contains a full date) the month and writes it into a new column "month_name" as a number
prec_long$month_name <- month(prec_long$Month, label = FALSE)#, abbr = FALSE)

# Calculates the 30-year average precipitation per month for all locations at once
avg_monthly <- prec_long %>%
  group_by(month_name) %>% 
  summarise(avg_value = mean(Precipitation, na.rm = TRUE))

# Creates a time series plot of the 30-year average precipitation per month for all locations at once
ggplot() + 
  geom_step(data =  avg_monthly, aes(x = month_name, y = avg_value), color = "salmon", linewidth = 1) +
  labs(x = "Month", y = "Precipitation", title = "Precipitation monthly 1990-2019 whole AOI") +
  theme_minimal(base_size = 14) 

```
## Zoom in on one randomly selected location 
The next chunk prepares and plots precipitation data for one particular location/grid cell.
The green line displays the 30-year monthly-average while the red points represent the individual years.

```{r single areas}

id <- prec_long %>%
  group_by(id)

random_cell = id %>% 
  subset(id == 10000) 

monthly_summary = random_cell %>% 
  group_by(month_name) %>% 
  summarise(avg_value = mean(Precipitation, na.rm = TRUE))

ggplot() + 
  geom_point(data =  random_cell, aes(x = month_name, y = Precipitation), color = "salmon") +
  geom_line(data = monthly_summary, aes(x = month_name, y = avg_value), color = "darkseagreen", linewidth = 1) +
  labs(x = "Month", y = "Precipitation", title = "Precipitation monthly 1990-2019") +
  theme_minimal(base_size = 14) 

```

## Cluster raster cells based on monthly average rainfall patterns  
```{r clusters}

# Selects the second to last column from prec_long. 
# This means the geometry column is dropped. 
prec_long_vect <- prec_long[2:5]
prec_long_vect_df <- as.data.frame(prec_long_vect)

# Applies the tk_tsfeatures function which computes a matrix of time series features that describes the various time series
tsfeature_tbl <- prec_long_vect_df %>% 
  group_by(id) %>% 
  tk_tsfeatures(
    .date_var = Month,
    .value = Precipitation,
    .period = 12,
    .features = c("frequency", "stl_features", "entropy", "acf_features"),
    .scale = TRUE,
    .prefix="ts_") %>% 
  ungroup()

head(tsfeature_tbl)

# Clusters the data using kmeans based on the time series features extraxted above.
cluster_tbl <- tibble(
    cluster = tsfeature_tbl %>% 
        select(-id) %>%
        as.matrix() %>%
        kmeans(centers = 3, nstart = 100) %>%
        pluck("cluster")
) %>%
    bind_cols(
        tsfeature_tbl
    )

head(cluster_tbl)

```
## Plotting the clusters

The next chunk plots which raster cells fall into which cluster.  
In addition, it generates a plot that shows the 30-year average of the yearly rainfall patterns in all three clusters.  

```{r plot clusters}

# Extracts the cluster number and id for each location and turns it into a dataframe.
clus <- cluster_tbl[1:2] %>% 
  data.frame()

# Binds the cluster number and id to the points dataset holding the original precipitation values.
prec_90_19_points$cluster <- clus

# Create a raster object into which the cluster values can be written.
r <- raster(prec_aoi_brick)

# Converts the points dataset from an sf object to a SpatialPointsDataset
prec_90_19_spdf <- as(prec_90_19_points, "Spatial")

# Makes a new object that has only the cluster number information
cluster_no <- prec_90_19_points$cluster

# Writes the cluster numbers into the prepared raster and plots the result.
prec_clust_rast <- rasterize(prec_90_19_spdf, raster(r), field = cluster_no)
plot(prec_clust_rast)

# To visualize clusters as plots:
# Merges the cluster numbers to the prec_ling data
prec_long_clus <- merge(prec_long, clus, by = "id")

# Groups data points that fall into the same cluster and calculates the averages per cluster
clust_facets <- prec_long_clus %>% 
  group_by(cluster, month_name) %>% 
  summarise(avg_value = mean(Precipitation, na.rum = TRUE))

# Makes a plot of the cluster averages
p <- ggplot() + 
  geom_line(data = clust_facets, aes(x = month_name, y = avg_value), color = "darkseagreen", linewidth = 1) +
  labs(x = "Month", y = "Precipitation", title = "Precipitation monthly 1990-2019") +
  theme_minimal(base_size = 14) 

# Plots the cluster averages as faceets
p + facet_grid(
  rows = vars(cluster)
)

```
# Rainy season months == months where it rains more than average?
# If it is supposed to rain more than average in one of the wetter months, then risk is increased?
# Check with Leo, Lise, etc?

## Identify months with above average rainfall  

The next chunk calculates the 30-year-average yearly rainfall and divides it by 12. This tells us how much precipitation would fall in every month, if precipitation was distributed equally throughout the year. Next, it identifies which months actually lie above and which do lie below the average. This way, we can identify which months constitute the "rainy season" and which constitute the "dry season".  

```{r months where it rains more than average}
# Groups by cluster
# Sums up all avg_values per cluster and divides by 12
avg_prec <- clust_facets %>% 
  group_by(cluster) %>% 
  summarize(total_prec_yearly = sum(avg_value, na.rum = TRUE)) %>% 
  mutate(avg_prec_monthly = total_prec_yearly / 12)

# Drops geometry column
avg_prec_vect <- st_drop_geometry(avg_prec) 

# Check if avg_value in month_name 1-12 is bigger or smaller than avg_value
clust_facets_avg <- merge(clust_facets, avg_prec_vect, by = "cluster")
# If avg_value in month_name[1] is bigger than avg_value, write value 1 into column "weight" 
# Add new column based on condition
clust_facets_avg$weight <- ifelse(clust_facets_avg$avg_value > clust_facets_avg$avg_prec_monthly, 1, 0)

# Visualize in plot
p <- ggplot() + 
  geom_line(data = clust_facets_avg, aes(x = month_name, y = avg_value), color = "darkseagreen", linewidth = 1) +
  geom_line(data = clust_facets_avg, aes(x = month_name, y = avg_prec_monthly), color = "salmon", linewidth = 1) +
  labs(x = "Month", y = "Precipitation", title = "Precipitation monthly 1990-2019") +
  theme_minimal(base_size = 14) 

# Show plots as facets
p + facet_grid(
  rows = vars(cluster)
)

```


```{r load precipitation forecasts}
# Load the forecast file(s)
# For more information on the data see here: https://codes.ecmwf.int/grib/param-db/?id=173228
prec_fore <- rast(here("data/rasters","seasonal_prec_forecast_2020_01_lead123456.grib"))

plot(prec_fore)
names(prec_fore) %>% 
  unique()
time(prec_fore)

# Set the correct layer names with the corresponding dates
names(prec_fore) <- paste("SFC (Ground or water surface);", time(prec_fore))

# Calculate the standard deviation and average for all AOI (all layers)
std_dev <- global(prec_fore, fun = "sd")
avg <- global(prec_fore, fun = "mean")

# Create a new raster with deviation information
deviation_raster <- ifel(prec_fore > (avg$mean + std_dev$sd), 1,
                         ifel(prec_fore < (avg$mean - std_dev$sd), -1, 0))

plot(deviation_raster)


# Extract one band of the CHIRPS data to which the resolution of the forecast will be matched to
r <- prec_aoi_brick$`chirps-v2.0.1999.01`
#deviation_raster <- project(deviation_raster, r)
# Resample the forecast resolution to the resolution of the CHIRPS data
prec_fore_resample <- terra::resample(deviation_raster, rast(r), method = "bilinear") 
plot(prec_fore_resample)
# Mask the bbox of the forecast to the AOI
prec_fore_deviation_resample_mask <- prec_fore_resample %>% 
  mask(r)

plot(prec_fore_deviation_resample_mask)

prec_fore_2020_02 <- prec_fore_deviation_resample_mask[[1]]
prec_fore_2020_03 <- prec_fore_deviation_resample_mask[[2]]
prec_fore_2020_04 <- prec_fore_deviation_resample_mask[[3]]
prec_fore_2020_05 <- prec_fore_deviation_resample_mask[[4]]
prec_fore_2020_06 <- prec_fore_deviation_resample_mask[[5]]
prec_fore_2020_07 <- prec_fore_deviation_resample_mask[[6]]

# Classify values into average, more and less than average (?)

# If, in any of the six coming months, it rains more than average in one of the rainy months (If prec_coming_june == above average && weight == 1, then assign value 1 to new column. If prec_coming_june == below average && weight == 1, then -1)

# Rainy season = 1 point baseline risk
# Rainy season definition = "> average_hist + 1 sd"
# Above average_forecast weight: +1

# Shoulder season = 0 points baseline risk
# Shoulder season definition = "average_hist +-1 sd"
# Above average_forecast weight: +1

# Dry season baseline risk = -1
# Dry season definition = "< average_hist - 1 sd"
# Above average_forecast weight: +1

```

```{r rainy season}
month <- prec_long %>%
  group_by(month_name, id)

month_avg_all <- month %>% 
  summarise(avg_value = mean(Precipitation, na.rm = TRUE))

###
# Start with 252 rasters
plot(prec_aoi_brick)

# Make 12 raster stacks (all January's, all February's,...)
# Assuming you have a terra raster with 252 bands named "prec_aoi_brick"
# Get the unique last two digits (months) from the band names
months <- unique(substr(names(prec_aoi_brick), nchar(names(prec_aoi_brick))-1, nchar(names(prec_aoi_brick))))

# Create 12 separate raster stacks, one for each month
monthly_stacks <- list()
for (month in months) {
  # Subset the bands that match the current month
  bands <- grep(paste0("\\.", month), names(prec_aoi_brick), value = TRUE)
  monthly_raster <- subset(prec_aoi_brick, subset = bands)
  # Rename the layers to remove the last two digits (month part) from the layer names
  names(monthly_raster) <- sub(paste0("\\.", month), "", names(monthly_raster))
  # Append the monthly raster stack to the list
  monthly_stacks[[month]] <- monthly_raster
}

#### Monthly stack pixel means
# Calculates the average rain in Jan, Feb, ... for each Pixel throughout the assessment period
monthly_means <- lapply(months, function(month){
  monthly_stack <- monthly_stacks[[month]]
  monthly_mean  <- mean(monthly_stack, na.rm = TRUE)
  return(monthly_mean)
})

# Make a stack from the 12 layers
monthly_means_stack <- rast(monthly_means)

# Calculate the sd for the precipitation throughout the year per pixel
std_dev_per_pixel <- terra::stdev(monthly_means_stack, na.rm = TRUE)

# Calculate the mean precipitation per pixel throughout the year
mean_per_pixel <- terra::mean(monthly_means_stack, na.rm = TRUE)

rainy_season <- ifel(monthly_means_stack > (mean_per_pixel$mean + std_dev_per_pixel$std), 1,
                        ifel(monthly_means_stack < (mean_per_pixel$mean - std_dev_per_pixel), -1, 0))

# Calculates standard deviation per pixel stack
# raster_stacks_std_devs <- lapply(monthly_means, function(raster_stack){
#   std_dev <- terra::stdev(raster_stack, na.rm = TRUE)
#   return(std_dev)
# })

# For each pixel, check if its average value in Jan, Feb,... is one sd bigger or smaller than the avg

# Integrate with forecast:
# Overlay Jan + Jan, Feb + Feb 
# Calulate total per cell for the 6 months
```